/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package beetag;

import com.google.zxing.common.*;
import com.google.zxing.*;
import com.google.zxing.common.GridSampler;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import javax.imageio.ImageIO;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.filechooser.*;
import javax.swing.table.*;


public class BEEtag extends javax.swing.JFrame {

    /**
     * Creates new form JFrame
     */
    public BEEtag() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        RecordTable = new javax.swing.JTable();
        jMenuBar1 = new javax.swing.JMenuBar();
        FileMenu = new javax.swing.JMenu();
        New = new javax.swing.JMenuItem();
        AddImg = new javax.swing.JMenuItem();
        AddDir = new javax.swing.JMenuItem();
        SaveAs = new javax.swing.JMenuItem();
        Close = new javax.swing.JMenuItem();
        EditMenu = new javax.swing.JMenu();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        RecordTable.setFont(new java.awt.Font("Courier New", 0, 12)); // NOI18N
        RecordTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {

            }
        ));
        RecordTable.getTableHeader().setReorderingAllowed(false);
        jScrollPane1.setViewportView(RecordTable);

        FileMenu.setText("File");

        New.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_N, java.awt.event.InputEvent.CTRL_MASK));
        New.setText("New Table");
        New.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                NewActionPerformed(evt);
            }
        });
        FileMenu.add(New);

        AddImg.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_MASK));
        AddImg.setText("Add Image...");
        AddImg.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                AddImgActionPerformed(evt);
            }
        });
        FileMenu.add(AddImg);

        AddDir.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        AddDir.setText("Add Directory...");
        AddDir.setToolTipText("");
        AddDir.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                AddDirActionPerformed(evt);
            }
        });
        FileMenu.add(AddDir);

        SaveAs.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        SaveAs.setText("Save As...");
        SaveAs.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SaveAsActionPerformed(evt);
            }
        });
        FileMenu.add(SaveAs);

        Close.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Q, java.awt.event.InputEvent.CTRL_MASK));
        Close.setText("Close");
        Close.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CloseActionPerformed(evt);
            }
        });
        FileMenu.add(Close);

        jMenuBar1.add(FileMenu);

        EditMenu.setText("Edit");
        jMenuBar1.add(EditMenu);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 279, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
 
    private void NewActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_NewActionPerformed
        //clear table and records of existing entries
        records.clear();
        while(mod.getRowCount() > 0)
            mod.removeRow(0);
    }//GEN-LAST:event_NewActionPerformed
    
    private void AddImgActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AddImgActionPerformed
        //add individual image files to current table
        JFileChooser fc = new JFileChooser();
        fc.setDialogTitle("Select Image(s)"); 
        fc.setFileSelectionMode(JFileChooser.FILES_ONLY); //no directories
        fc.setMultiSelectionEnabled(true); //allow multiple files to be selected
        
        //only show image files for selection
        FileFilter imageFilter = new FileNameExtensionFilter("Image Files", ImageIO.getReaderFileSuffixes());
        fc.setFileFilter(imageFilter);
        
        //open dialog and convert when Open selected
        if(fc.showOpenDialog(this) == JFileChooser.APPROVE_OPTION){
            File[] imgFiles = fc.getSelectedFiles();
            convert(imgFiles);
        }
    }//GEN-LAST:event_AddImgActionPerformed

    private void AddDirActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AddDirActionPerformed
        //add all image files in directory to current table
        JFileChooser fc = new JFileChooser();
        fc.setDialogTitle("Select Image Folder"); 
        fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY); //no files
        
        //open dialog and convert when Open selected
        if(fc.showOpenDialog(this) == JFileChooser.APPROVE_OPTION){
            File dir = fc.getSelectedFile();
            convert(dir.listFiles());
        }
    }//GEN-LAST:event_AddDirActionPerformed

    private void SaveAsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SaveAsActionPerformed
        JFileChooser fc = new JFileChooser();
        fc.setDialogTitle("Save CSV File");
        
        //show only csv files
        fc.setFileFilter(new FileNameExtensionFilter("csv file","csv"));

        //open dialog and save when Save selected
        if(fc.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
            File out = fc.getSelectedFile();
            String path = out.getPath();
            if(!path.endsWith(".csv"))
                path += ".csv";
            writeCSV(path);
        }
    }//GEN-LAST:event_SaveAsActionPerformed

    private void CloseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CloseActionPerformed
        //close program
        System.exit(0);
    }//GEN-LAST:event_CloseActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(BEEtag.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        
        BEEtag bt = new BEEtag();
        bt.records = new ArrayList<>();
        bt.RecordTable.setRowHeight(bt.rowsize);
        bt.RecordTable.setDefaultRenderer(String.class, new MultiLineCellRenderer());
        bt.RecordTable.setDefaultEditor(String.class, new MultiLineCellEditor());
        
        //set up table to display results
        final String[] col = {"Image", "Decoded", "ID", "Time"}; //column headings
        bt.mod = new DefaultTableModel(col, 0){
            @Override
            public Class getColumnClass(int columnIndex) {
                if(columnIndex == 0)
                    return Icon.class; //first column is image icons
                else
                    return String.class; //all other columns are strings
            }
            
            @Override
            public boolean isCellEditable(int row, int column) {
                return column == 1; //only allow detected tag to be edited
            }
        };
        
        TableModelListener listen = (TableModelEvent e) -> {
            if(e.getColumn() == 1 && e.getType() == TableModelEvent.UPDATE){
                bt.updateDec(e.getFirstRow());
            }
        };
        bt.mod.addTableModelListener(listen);

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            bt.setVisible(true);
        });
    }
    
    private void convert(File[] inFiles)
    {
        for(File imgFile: inFiles){
            BufferedImage img;
            BasicFileAttributes attr;
            try{
                //get image to buffered image
                img = ImageIO.read(imgFile);
                attr = Files.readAttributes(imgFile.toPath(), BasicFileAttributes.class);
            }
            catch(IOException e){
                System.err.println("Invalid image file " + imgFile.getPath() + ".");
                continue;
            }

            int[] intArray = img.getRGB(0, 0, img.getWidth(), img.getHeight(), null, 0, img.getWidth());

            //create LuminanceSource and run through Binarizer to get BinaryBitmap
            LuminanceSource source = new RGBLuminanceSource(img.getWidth(), img.getHeight(), intArray);
            BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));
            BitMatrix reader;
            BitMatrix bits = new BitMatrix(5,5);

            try{
                //find code in picture and return corner locations
                ModDetector detector = new ModDetector(bitmap.getBlackMatrix());
                ResultPoint[] corners = detector.detect();

                //convert code into its binary representation stored in BitMatrix
                GridSampler sampler = GridSampler.getInstance();
                int res = 7;
                reader = sampler.sampleGrid(bitmap.getBlackMatrix(), res, res,
                        0.5f, 0.5f, res - 0.5f, 0.5f, res - 0.5f, res - 0.5f, 0.5f, res - 0.5f,
                        corners[0].getX(), corners[0].getY(), corners[2].getX(), corners[2].getY(),
                        corners[3].getX(), corners[3].getY(), corners[1].getX(), corners[1].getY());
                
                //crop original image to only BEEtag
                int w = (int) ((int)Math.max(corners[2].getX(), corners[3].getX()) - corners[0].getX());
                int h = (int) ((int)Math.max(corners[1].getY(), corners[3].getY()) - corners[0].getY());
                img = img.getSubimage((int)corners[0].getX(), (int)corners[0].getY(), w, h);
                
                for(int j = 1; j < 6; j++)
                    for(int i = 1; i < 6; i++)
                        if(reader.get(i,j))
                            bits.set((i-1),(j-1));
            }
            catch(NotFoundException e){
                //couldn't find code in image
                System.err.println("Error: No valid code found in " + imgFile.getName() + ".");
                continue;
            }
            //NOTE: "row" and "column" are used below referring to the original orientation of the tag
            //The BEEtag specification uses "column" to refer to rows in the original orientation when mentioning the parity format
            //Also note that BEEtag uses white for 1 and 0 for black while ZXing uses true for black and false for white.
            int dec = -1;

            for(int i = 0; i < 4; i++){
                dec = decode(bits);
                if(dec != -1) { //found valid tag orientation
                    ArrayList<String> values = new ArrayList<>(); //list of strings to put to table
                    values.add(bits.toString());
                    values.add(Integer.toString(dec)); //tag ID
                    values.add(attr.creationTime().toString()); //file creation time (temp)
                    records.add(values); //save to records arraylist

                    Object[] row = new Object[values.size()+1]; //leave space for thumbnail

                    //scale down image to thumbnail size
                    BufferedImage thumb = new BufferedImage(rowsize-10, rowsize-10, BufferedImage.TYPE_INT_RGB);
                    Graphics g = thumb.createGraphics();
                    g.drawImage(img, 0, 0, rowsize-10, rowsize-10, null);
                    g.dispose();

                    //create icon from image and put in row
                    ImageIcon icon = new ImageIcon(thumb);
                    row[0] = icon;
                    for(int j=0; j<values.size(); j++)
                        row[j+1] = values.get(j);

                    //add row to table
                    mod.addRow(row);
                    break;
                }else{
                    bits = rotate(bits, 5);
                }
            }

            if(dec == -1){
                //all parity checks failed
                //show user failed read in table but don't write to csv
                ArrayList<String> values = new ArrayList<>(); //list of strings to put to table
                records.add(values); //add empty placeholder to records
                values.add(bits.toString());
                values.add("ERROR"); //tag ID
                values.add(attr.creationTime().toString()); //file creation time (temp)

                Object[] row = new Object[values.size()+1]; //leave space for thumbnail

                //scale down image to thumbnail size
                BufferedImage thumb = new BufferedImage(rowsize-10, rowsize-10, BufferedImage.TYPE_INT_RGB);
                Graphics g = thumb.createGraphics();
                g.drawImage(img, 0, 0, rowsize-10, rowsize-10, null);
                g.dispose();

                //create icon from image and put in row
                ImageIcon icon = new ImageIcon(thumb);
                row[0] = icon;
                for(int j=0; j<values.size(); j++)
                    row[j+1] = values.get(j);

                //add row to table
                mod.addRow(row);
            }

        } //for all files in directory
        RecordTable.setModel(mod);
    } //convert

    private BitMatrix rotate(BitMatrix bits, int size)
    {
        BitMatrix x = new BitMatrix(size, size);
        for (int i = 0; i < size; ++i) {
            for (int j = 0; j < size; ++j) {
                if(bits.get(size - j - 1, i))
                    x.set(i, j);
            }
        }
        return x;
    } //rotate

    private int decode(BitMatrix bits)
    {
        int dec = 0; //stores decimal number of tag
        int[] par = new int[5]; //stores expected parity results

        //convert BitMatrix into decimal representation and set column parity bits
        for(int i=0; i<3; i++){ //for first 3 columns
            par[i] = 0; //initialize to even (0)

            for(int j=0; j<5; j++){ //for each row
                if(!bits.get(i, j)) { //if white square (representing 1)
                    dec += Math.pow(2, 14 - 5 * i - j);
                    par[i] = 1 - par[i]; //flip parity for each white
                }
            }
        }

        //set last two parity bits
        par[3] = 0; //initialize to even (0)
        for(int j=0; j<3; j++){ //for first 3 rows
            for(int i=0; i<3; i++){ //for first 3 columns
                if(!bits.get(i, j)) { //if white square (representing 1)
                    par[3] = 1 - par[3]; //flip parity for each white
                }
            }
        }

        par[4] = 0; //initialize to even (0)
        for(int j=3; j<5; j++){ //for last 2 rows
            for(int i=0; i<3; i++){ //for first 3 columns
                if(!bits.get(i, j)) { //if white square (representing 1)
                    par[4] = 1 - par[4]; //flip parity for each white
                }
            }
        }

        //check parity for 4th column
        for(int j=0; j<5; j++){ //for each row
            if((!bits.get(3, j) && par[j] == 0) || (bits.get(3, j) && par[j] == 1)){ //if failed parity check
                return -1;
            }
        }

        //check parity for 5th column (reverse of 4th column)
        for(int j=0; j<5; j++){ //for each row
            if((!bits.get(4, j) && par[4-j] == 0) || (bits.get(4, j) && par[4-j] == 1)){ //if failed parity check
                return -1;
            }
        }
        return dec;
    } //decode
    
    private void updateDec(int row)
    {
        //update table based on newly edited BitMatrix
        String bitStr = (String)mod.getValueAt(row, 1);
        BitMatrix bits;
        int dec = -1;
        
        //decode BitMatrix from new string
        try{
            bits = BitMatrix.parse(bitStr, "X ", "  ");
        }
        catch(IllegalArgumentException e){
            //not a valid BitMatrix string, reset to all black
            System.err.println("Invalid BEEtag shape. Resetting to all black.");
            String defStr = "X X X X X \n"
                          + "X X X X X \n"
                          + "X X X X X \n"
                          + "X X X X X \n"
                          + "X X X X X \n";
            mod.setValueAt(defStr, row, 1);
            mod.setValueAt("ERROR", row, 2); //invalid barcode
            return;
        }

        for(int i = 0; i < 4; i++){
            dec = decode(bits);
            if(dec != -1) { //found valid tag orientation
                mod.setValueAt(Integer.toString(dec), row, 2); //update decimal in table
                
                //add values from table to arraylist to write to CSV
                ArrayList<String> values = new ArrayList<>();
                for(int j = 1; j < 4; j++){
                    values.add((String)mod.getValueAt(row, j));
                }
                
                records.set(row, values); //save to records arraylist
                return;
            }
            else{
                bits = rotate(bits, 5);
            }
        }
        
        if(dec == -1)
            mod.setValueAt("ERROR", row, 2); //invalid barcode
    } //updateDec
    
    private void writeCSV(String outFile)
    {
        if(records.isEmpty()){
            System.err.println("Nothing to save.");
            return;
        }
        
        try(FileWriter writer = new FileWriter(outFile)) {
            writer.append("ID,Time\n"); //write header

            for(ArrayList<String> record : records){ //for each record
                if(record.isEmpty())
                    continue; //skip empty records
                writer.append(record.get(1)); //start at 1 to skip bit matrix
                for(int i=2; i<record.size(); i++){ //for each element in record
                    writer.append("," + record.get(i));
                } //for each element in record
                writer.append("\n");
            } //for each record

            writer.flush();
            System.out.println("Wrote to output file " + outFile + ".");
        }
        catch(IOException e){
            System.err.println("Failed to write to CSV.");
        }
    } //writeCSV
    
    private final int rowsize = 90; //height of each row in pixels
    private ArrayList<ArrayList<String>> records; //stores records to write to CSV
    private DefaultTableModel mod; //stores contents of table to display
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem AddDir;
    private javax.swing.JMenuItem AddImg;
    private javax.swing.JMenuItem Close;
    private javax.swing.JMenu EditMenu;
    private javax.swing.JMenu FileMenu;
    private javax.swing.JMenuItem New;
    private javax.swing.JTable RecordTable;
    private javax.swing.JMenuItem SaveAs;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JScrollPane jScrollPane1;
    // End of variables declaration//GEN-END:variables
}


//CellRenderer and CellEditor for supporting multiple lines in one cell
//Needed in order to display BitMatrix in a readable manner
class MultiLineCellRenderer extends JTextArea implements TableCellRenderer {
  @Override
  public Component getTableCellRendererComponent(JTable table, Object value,
      boolean isSelected, boolean hasFocus, int row, int column) {
    if (isSelected) {
      setForeground(table.getSelectionForeground());
      setBackground(table.getSelectionBackground());
    } else {
      setForeground(table.getForeground());
      setBackground(table.getBackground());
    }
    setFont(table.getFont());
    if (hasFocus) {
      setBorder(UIManager.getBorder("Table.focusCellHighlightBorder"));
      if (table.isCellEditable(row, column)) {
        setForeground(UIManager.getColor("Table.focusCellForeground"));
        setBackground(UIManager.getColor("Table.focusCellBackground"));
      }
    } else {
      setBorder(new EmptyBorder(1, 2, 1, 2));
    }
    setText((value == null) ? "" : value.toString());
    return this;
  }
}

class MultiLineCellEditor extends AbstractCellEditor implements TableCellEditor {

    JComponent component = new JTextArea();

    @Override
    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected,
        int rowIndex, int vColIndex) {

        ((JTextArea) component).setText((String) value);

        return component;
    }

    @Override
    public Object getCellEditorValue() {
        return ((JTextArea) component).getText();
    }
}
