/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package beetag;

import com.google.zxing.common.*;
import com.google.zxing.*;
import com.google.zxing.common.GridSampler;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import javax.imageio.ImageIO;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellRenderer;


public class BEEtag extends javax.swing.JFrame {

    /**
     * Creates new form JFrame
     */
    public BEEtag() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        RecordTable = new javax.swing.JTable();
        jMenuBar1 = new javax.swing.JMenuBar();
        FileMenu = new javax.swing.JMenu();
        New = new javax.swing.JMenuItem();
        AddImg = new javax.swing.JMenuItem();
        AddDir = new javax.swing.JMenuItem();
        SaveAs = new javax.swing.JMenuItem();
        Close = new javax.swing.JMenuItem();
        EditMenu = new javax.swing.JMenu();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        RecordTable.setFont(new java.awt.Font("Courier New", 0, 12)); // NOI18N
        RecordTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {

            }
        ));
        RecordTable.getTableHeader().setReorderingAllowed(false);
        jScrollPane1.setViewportView(RecordTable);

        FileMenu.setText("File");

        New.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_N, java.awt.event.InputEvent.CTRL_MASK));
        New.setText("New Table");
        New.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                NewActionPerformed(evt);
            }
        });
        FileMenu.add(New);

        AddImg.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_MASK));
        AddImg.setText("Add Image...");
        AddImg.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                AddImgActionPerformed(evt);
            }
        });
        FileMenu.add(AddImg);

        AddDir.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        AddDir.setText("Add Directory...");
        AddDir.setToolTipText("");
        AddDir.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                AddDirActionPerformed(evt);
            }
        });
        FileMenu.add(AddDir);

        SaveAs.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        SaveAs.setText("Save As...");
        SaveAs.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SaveAsActionPerformed(evt);
            }
        });
        FileMenu.add(SaveAs);

        Close.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Q, java.awt.event.InputEvent.CTRL_MASK));
        Close.setText("Close");
        Close.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CloseActionPerformed(evt);
            }
        });
        FileMenu.add(Close);

        jMenuBar1.add(FileMenu);

        EditMenu.setText("Edit");
        jMenuBar1.add(EditMenu);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 279, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
 
    private void NewActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_NewActionPerformed
        //clear table and records of existing entries
        records.clear();
        mod.setRowCount(0);
    }//GEN-LAST:event_NewActionPerformed
    
    private void AddImgActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AddImgActionPerformed
        //add individual image files to current table
        JFileChooser fc = new JFileChooser();
        fc.setDialogTitle("Select Image(s)"); 
        fc.setFileSelectionMode(JFileChooser.FILES_ONLY); //no directories
        fc.setMultiSelectionEnabled(true); //allow multiple files to be selected
        
        //only show image files for selection
        FileFilter imageFilter = new FileNameExtensionFilter("Image Files", ImageIO.getReaderFileSuffixes());
        fc.setFileFilter(imageFilter);
        
        //open dialog and convert when Open selected
        if(fc.showOpenDialog(this) == JFileChooser.APPROVE_OPTION){
            File[] imgFiles = fc.getSelectedFiles();
            convert(imgFiles);
        }
    }//GEN-LAST:event_AddImgActionPerformed

    private void AddDirActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AddDirActionPerformed
        //add all image files in directory to current table
        JFileChooser fc = new JFileChooser();
        fc.setDialogTitle("Select Image Folder"); 
        fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY); //no files
        
        //open dialog and convert when Open selected
        if(fc.showOpenDialog(this) == JFileChooser.APPROVE_OPTION){
            File dir = fc.getSelectedFile();
            convert(dir.listFiles());
        }
    }//GEN-LAST:event_AddDirActionPerformed

    private void SaveAsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SaveAsActionPerformed
        JFileChooser fc = new JFileChooser();
        fc.setDialogTitle("Save CSV File");
        
        //show only csv files
        fc.setFileFilter(new FileNameExtensionFilter("csv file","csv"));

        //open dialog and save when Save selected
        if(fc.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
            File out = fc.getSelectedFile();
            String path = out.getPath();
            if(!path.endsWith(".csv"))
                path += ".csv";
            writeCSV(path);
        }
    }//GEN-LAST:event_SaveAsActionPerformed

    private void CloseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CloseActionPerformed
        //close program
        System.exit(0);
    }//GEN-LAST:event_CloseActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(BEEtag.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        
        BEEtag bt = new BEEtag();
        bt.records = new ArrayList<>();
        bt.RecordTable.setRowHeight(bt.rowsize);
        bt.RecordTable.setDefaultRenderer(String.class, new MultiLineCellRenderer());
        
        //set up table to display results
        final String[] col = {"Image", "Decoded", "ID", "Time"}; //column headings
        bt.mod = new DefaultTableModel(col, 0){
            @Override
            public Class getColumnClass(int columnIndex) {
                if(columnIndex == 0)
                    return Icon.class; //first column is image icons
                else
                    return String.class; //all other columns are strings
            }
            
            @Override
            public boolean isCellEditable(int row, int column) {
               //all cells false
               return false;
            }
        };

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            bt.setVisible(true);
        });
    }
    
    private void convert(File[] inFiles){
        for(File imgFile: inFiles){
            BufferedImage img;
            BasicFileAttributes attr;
            try{
                //get image to buffered image
                img = ImageIO.read(imgFile);
                attr = Files.readAttributes(imgFile.toPath(), BasicFileAttributes.class);
            }
            catch(IOException e){
                System.err.println("Invalid image file " + imgFile.getPath() + ".");
                continue;
            }

            int[] intArray = img.getRGB(0, 0, img.getWidth(), img.getHeight(), null, 0, img.getWidth());

            //create LuminanceSource and run through Binarizer to get BinaryBitmap
            LuminanceSource source = new RGBLuminanceSource(img.getWidth(), img.getHeight(), intArray);
            BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));
            BitMatrix reader;
            BitMatrix bits = new BitMatrix(5,5);

            try{
                //find code in picture and return corner locations
                ModDetector detector = new ModDetector(bitmap.getBlackMatrix());
                ResultPoint[] corners = detector.detect();

                //convert code into its binary representation stored in BitMatrix
                GridSampler sampler = GridSampler.getInstance();
                int res = 7;
                reader = sampler.sampleGrid(bitmap.getBlackMatrix(), res, res,
                        0.5f, 0.5f, res - 0.5f, 0.5f, res - 0.5f, res - 0.5f, 0.5f, res - 0.5f,
                        corners[0].getX(), corners[0].getY(), corners[2].getX(), corners[2].getY(),
                        corners[3].getX(), corners[3].getY(), corners[1].getX(), corners[1].getY());
                
                //crop original image to only BEEtag
                int w = (int) ((int)Math.max(corners[2].getX(), corners[3].getX()) - corners[0].getX());
                int h = (int) ((int)Math.max(corners[1].getY(), corners[3].getY()) - corners[0].getY());
                img = img.getSubimage((int)corners[0].getX(), (int)corners[0].getY(), w, h);
                
                for(int j = 1; j < 6; j++)
                    for(int i = 1; i < 6; i++)
                        if(reader.get(i,j))
                            bits.set((i-1),(j-1));
            }
            catch(NotFoundException e){
                //couldn't find code in image
                System.err.println("Error: No valid code found in " + imgFile.getName() + ".");
                continue;
            }
            
            //NOTE: "row" and "column" are used below referring to the original orientation of the tag
            //The BEEtag specification uses "column" to refer to rows in the original orientation when mentioning the parity format
            //Also note that BEEtag uses white for 1 and 0 for black while ZXing uses true for black and false for white.
            int dec = -1;

            for(int i = 0; i < 4; i++){
                dec = decode(bits);
                if(dec != -1) { //found valid tag orientation
                    ArrayList<String> values = new ArrayList<>(); //list of strings to write to csv
                    values.add(bits.toString());
                    values.add(Integer.toString(dec)); //tag ID
                    values.add(attr.creationTime().toString()); //file creation time (temp)
                    records.add(values); //save to records arraylist
                    
                    Object[] row = new Object[values.size()+1]; //leave space for thumbnail
                
                    //scale down image to thumbnail size
                    BufferedImage thumb = new BufferedImage(rowsize-10, rowsize-10, BufferedImage.TYPE_INT_RGB);
                    Graphics g = thumb.createGraphics();
                    g.drawImage(img, 0, 0, rowsize-10, rowsize-10, null);
                    g.dispose();

                    //create icon from image and put in row
                    ImageIcon icon = new ImageIcon(thumb);
                    row[0] = icon;
                    for(int j=0; j<values.size(); j++)
                        row[j+1] = values.get(j);

                    //add row to table
                    mod.addRow(row);
                    break;
                }else{
                    bits = rotate(bits, 5);
                }
            }
            
            if(dec == -1){
                //all parity checks failed, display error message
                System.err.println("Error: All orientations failed for " + imgFile.getName() + ".");
                
                //show user failed read in table but don't write to csv
                ArrayList<String> values = new ArrayList<>(); //list of strings to write to csv
                values.add(bits.toString());
                values.add("ERROR"); //tag ID
                values.add(attr.creationTime().toString()); //file creation time (temp)

                Object[] row = new Object[values.size()+1]; //leave space for thumbnail
                
                //scale down image to thumbnail size
                BufferedImage thumb = new BufferedImage(rowsize-10, rowsize-10, BufferedImage.TYPE_INT_RGB);
                Graphics g = thumb.createGraphics();
                g.drawImage(img, 0, 0, rowsize-10, rowsize-10, null);
                g.dispose();
                
                //create icon from image and put in row
                ImageIcon icon = new ImageIcon(thumb);
                row[0] = icon;
                for(int j=0; j<values.size(); j++)
                    row[j+1] = values.get(j);
                
                //add row to table
                mod.addRow(row);
            }
        } //for all files in directory
        RecordTable.setModel(mod);
    } //convert

    private BitMatrix rotate(BitMatrix bits, int size){
        BitMatrix x = new BitMatrix(size, size);
        for (int i = 0; i < size; ++i) {
            for (int j = 0; j < size; ++j) {
                if(bits.get(size - j - 1, i))
                    x.set(i, j);
            }
        }
        return x;
    } //rotate

    private int decode(BitMatrix bits){
        int dec = 0; //stores decimal number of tag
        int[] par = new int[5]; //stores expected parity results

        //convert BitMatrix into decimal representation and set column parity bits
        for(int i=0; i<3; i++){ //for first 3 columns
            par[i] = 0; //initialize to even (0)

            for(int j=0; j<5; j++){ //for each row
                if(!bits.get(i, j)) { //if white square (representing 1)
                    dec += Math.pow(2, 14 - 5 * i - j);
                    par[i] = 1 - par[i]; //flip parity for each white
                }
            }
        }

        //set last two parity bits
        par[3] = 0; //initialize to even (0)
        for(int j=0; j<3; j++){ //for first 3 rows
            for(int i=0; i<3; i++){ //for first 3 columns
                if(!bits.get(i, j)) { //if white square (representing 1)
                    par[3] = 1 - par[3]; //flip parity for each white
                }
            }
        }

        par[4] = 0; //initialize to even (0)
        for(int j=3; j<5; j++){ //for last 2 rows
            for(int i=0; i<3; i++){ //for first 3 columns
                if(!bits.get(i, j)) { //if white square (representing 1)
                    par[4] = 1 - par[4]; //flip parity for each white
                }
            }
        }

        //check parity for 4th column
        for(int j=0; j<5; j++){ //for each row
            if((!bits.get(3, j) && par[j] == 0) || (bits.get(3, j) && par[j] == 1)){ //if failed parity check
                return -1;
            }
        }

        //check parity for 5th column (reverse of 4th column)
        for(int j=0; j<5; j++){ //for each row
            if((!bits.get(4, j) && par[4-j] == 0) || (bits.get(4, j) && par[4-j] == 1)){ //if failed parity check
                return -1;
            }
        }
        return dec;
    } //decode
    
    private void writeCSV(String outFile)
    {
        if(records.isEmpty()){
            System.err.println("Nothing to save.");
            return;
        }
        
        try(FileWriter writer = new FileWriter(outFile)) {
            writer.append("ID,Time\n"); //write header

            for(ArrayList<String> record : records){ //for each record
                writer.append(record.get(1)); //start at 1 to skip bit matrix
                for(int i=2; i<record.size(); i++){ //for each element in record
                    writer.append("," + record.get(i));
                } //for each element in record
                writer.append("\n");
            } //for each record

            writer.flush();
            System.out.println("Wrote to output file " + outFile + ".");
        }
        catch(IOException e){
            System.err.println("Failed to write to CSV.");
        }
    } //writeCSV

    public final class ModDetector {

        private static final int INIT_SIZE = 10;
        private static final int CORR = 1;

        private final BitMatrix image;
        private final int height;
        private final int width;
        private final int leftInit;
        private final int rightInit;
        private final int downInit;
        private final int upInit;

        public ModDetector(BitMatrix image) throws NotFoundException {
            this(image, INIT_SIZE, image.getWidth() / 2, image.getHeight() / 2);
        }

        /**
         * @param image barcode image to find a rectangle in
         * @param initSize initial size of search area around center
         * @param x x position of search center
         * @param y y position of search center
         * @throws NotFoundException if image is too small to accommodate {@code initSize}
         */
        public ModDetector(BitMatrix image, int initSize, int x, int y) throws NotFoundException {
            this.image = image;
            height = image.getHeight();
            width = image.getWidth();
            int halfsize = initSize / 2;
            leftInit = x - halfsize;
            rightInit = x + halfsize;
            upInit = y - halfsize;
            downInit = y + halfsize;
            if (upInit < 0 || leftInit < 0 || downInit >= height || rightInit >= width) {
                throw NotFoundException.getNotFoundInstance();
            }
        }

        /**
         * <p>
         * Detects a candidate barcode-like rectangular region within an image. It
         * starts around the center of the image, increases the size of the candidate
         * region until it finds a white rectangular region.
         * </p>
         *
         * @return {@link ResultPoint}[] describing the corners of the rectangular
         *         region. The first and last points are opposed on the diagonal, as
         *         are the second and third. The first point will be the topmost
         *         point and the last, the bottommost. The second point will be
         *         leftmost and the third, the rightmost
         * @throws NotFoundException if no Data Matrix Code can be found
         */
        public ResultPoint[] detect() throws NotFoundException {

            int left = leftInit;
            int right = rightInit;
            int up = upInit;
            int down = downInit;
            boolean sizeExceeded = false;
            boolean aBlackPointFoundOnBorder = true;
            boolean atLeastOneBlackPointFoundOnBorder = false;

            boolean atLeastOneBlackPointFoundOnRight = false;
            boolean atLeastOneBlackPointFoundOnBottom = false;
            boolean atLeastOneBlackPointFoundOnLeft = false;
            boolean atLeastOneBlackPointFoundOnTop = false;

            while (aBlackPointFoundOnBorder) {

                aBlackPointFoundOnBorder = false;

                // .....
                // .   |
                // .....
                boolean rightBorderNotWhite = true;
                while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {
                    rightBorderNotWhite = containsBlackPoint(up, down, right, false);
                    if (rightBorderNotWhite) {
                        right++;
                        aBlackPointFoundOnBorder = true;
                        atLeastOneBlackPointFoundOnRight = true;
                    } else if (!atLeastOneBlackPointFoundOnRight) {
                        right++;
                    }
                }

                if (right >= width) {
                    sizeExceeded = true;
                    break;
                }

                // .....
                // .   .
                // .___.
                boolean bottomBorderNotWhite = true;
                while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {
                    bottomBorderNotWhite = containsBlackPoint(left, right, down, true);
                    if (bottomBorderNotWhite) {
                        down++;
                        aBlackPointFoundOnBorder = true;
                        atLeastOneBlackPointFoundOnBottom = true;
                    } else if (!atLeastOneBlackPointFoundOnBottom) {
                        down++;
                    }
                }

                if (down >= height) {
                    sizeExceeded = true;
                    break;
                }

                // .....
                // |   .
                // .....
                boolean leftBorderNotWhite = true;
                while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {
                    leftBorderNotWhite = containsBlackPoint(up, down, left, false);
                    if (leftBorderNotWhite) {
                        left--;
                        aBlackPointFoundOnBorder = true;
                        atLeastOneBlackPointFoundOnLeft = true;
                    } else if (!atLeastOneBlackPointFoundOnLeft) {
                        left--;
                    }
                }

                if (left < 0) {
                    sizeExceeded = true;
                    break;
                }

                // .___.
                // .   .
                // .....
                boolean topBorderNotWhite = true;
                while ((topBorderNotWhite  || !atLeastOneBlackPointFoundOnTop) && up >= 0) {
                    topBorderNotWhite = containsBlackPoint(left, right, up, true);
                    if (topBorderNotWhite) {
                        up--;
                        aBlackPointFoundOnBorder = true;
                        atLeastOneBlackPointFoundOnTop = true;
                    } else if (!atLeastOneBlackPointFoundOnTop) {
                        up--;
                    }
                }

                if (up < 0) {
                    sizeExceeded = true;
                    break;
                }

                if (aBlackPointFoundOnBorder) {
                    atLeastOneBlackPointFoundOnBorder = true;
                }

            }//while

            if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {
                ResultPoint z;
                z = new ResultPoint(left-1, down+1);
                if (z == null)
                    throw NotFoundException.getNotFoundInstance();

                ResultPoint t;
                //go down right
                t = new ResultPoint(left-1, up-1);
                if (t == null)
                    throw NotFoundException.getNotFoundInstance();

                ResultPoint x;
                //go down left
                x = new ResultPoint(right+1 , up-1);
                if (x == null)
                    throw NotFoundException.getNotFoundInstance();

                ResultPoint y;
                //go up left
                y = new ResultPoint(right+1 , down-1);
                if (y == null)
                    throw NotFoundException.getNotFoundInstance();

                return centerEdges(y, z, x, t);

            } else {
                throw NotFoundException.getNotFoundInstance();
            }
        }

        /**
         * recenters the points of a constant distance towards the center
         *
         * @param y bottom most point
         * @param z left most point
         * @param x right most point
         * @param t top most point
         * @return {@link ResultPoint}[] describing the corners of the rectangular
         *         region. The first and last points are opposed on the diagonal, as
         *         are the second and third. The first point will be the topmost
         *         point and the last, the bottommost. The second point will be
         *         leftmost and the third, the rightmost
         */
        private ResultPoint[] centerEdges(ResultPoint y, ResultPoint z,
                                          ResultPoint x, ResultPoint t) {

            //
            //       t            t
            //  z                      x
            //        x    OR    z
            //   y                    y
            //

            float yi = y.getX();
            float yj = y.getY();
            float zi = z.getX();
            float zj = z.getY();
            float xi = x.getX();
            float xj = x.getY();
            float ti = t.getX();
            float tj = t.getY();

            if (yi < width / 2.0f) {
                return new ResultPoint[]{
                        new ResultPoint(ti - CORR, tj + CORR),
                        new ResultPoint(zi + CORR, zj + CORR),
                        new ResultPoint(xi - CORR, xj - CORR),
                        new ResultPoint(yi + CORR, yj - CORR)};
            } else {
                return new ResultPoint[]{
                        new ResultPoint(ti + CORR, tj + CORR),
                        new ResultPoint(zi + CORR, zj - CORR),
                        new ResultPoint(xi - CORR, xj + CORR),
                        new ResultPoint(yi - CORR, yj - CORR)};
            }
        }

        /**
         * Determines whether a segment contains a black point
         *
         * @param a          min value of the scanned coordinate
         * @param b          max value of the scanned coordinate
         * @param fixed      value of fixed coordinate
         * @param horizontal set to true if scan must be horizontal, false if vertical
         * @return true if a black point has been found, else false.
         */
        private boolean containsBlackPoint(int a, int b, int fixed, boolean horizontal) {

            if (horizontal) {
                for (int x = a; x <= b; x++) {
                    if (image.get(x, fixed)) {
                        return true;
                    }
                }
            } else {
                for (int y = a; y <= b; y++) {
                    if (image.get(fixed, y)) {
                        return true;
                    }
                }
            }

            return false;
        }

    }
    
    private final int rowsize = 90; //height of each row in pixels
    private ArrayList<ArrayList<String>> records; //stores records to write to CSV
    private DefaultTableModel mod; //stores contents of table to display
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem AddDir;
    private javax.swing.JMenuItem AddImg;
    private javax.swing.JMenuItem Close;
    private javax.swing.JMenu EditMenu;
    private javax.swing.JMenu FileMenu;
    private javax.swing.JMenuItem New;
    private javax.swing.JTable RecordTable;
    private javax.swing.JMenuItem SaveAs;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JScrollPane jScrollPane1;
    // End of variables declaration//GEN-END:variables
}



class MultiLineCellRenderer extends JTextArea implements TableCellRenderer {
  @Override
  public Component getTableCellRendererComponent(JTable table, Object value,
      boolean isSelected, boolean hasFocus, int row, int column) {
    if (isSelected) {
      setForeground(table.getSelectionForeground());
      setBackground(table.getSelectionBackground());
    } else {
      setForeground(table.getForeground());
      setBackground(table.getBackground());
    }
    setFont(table.getFont());
    if (hasFocus) {
      setBorder(UIManager.getBorder("Table.focusCellHighlightBorder"));
      if (table.isCellEditable(row, column)) {
        setForeground(UIManager.getColor("Table.focusCellForeground"));
        setBackground(UIManager.getColor("Table.focusCellBackground"));
      }
    } else {
      setBorder(new EmptyBorder(1, 2, 1, 2));
    }
    setText((value == null) ? "" : value.toString());
    return this;
  }
}
