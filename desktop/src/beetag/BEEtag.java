/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package beetag;

import com.google.zxing.*;
import com.google.zxing.common.*;
import com.google.zxing.common.detector.WhiteRectangleDetector;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import javax.imageio.ImageIO;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellRenderer;


public class BEEtag extends javax.swing.JFrame {

    /**
     * Creates new form JFrame
     */
    public BEEtag() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        RecordTable = new javax.swing.JTable();
        jMenuBar1 = new javax.swing.JMenuBar();
        FileMenu = new javax.swing.JMenu();
        Open = new javax.swing.JMenuItem();
        SaveAs = new javax.swing.JMenuItem();
        EditMenu = new javax.swing.JMenu();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        RecordTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {

            }
        ));
        RecordTable.getTableHeader().setReorderingAllowed(false);
        jScrollPane1.setViewportView(RecordTable);

        FileMenu.setText("File");

        Open.setText("Open...");
        Open.setToolTipText("");
        Open.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                OpenActionPerformed(evt);
            }
        });
        FileMenu.add(Open);

        SaveAs.setText("Save As...");
        SaveAs.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SaveAsActionPerformed(evt);
            }
        });
        FileMenu.add(SaveAs);

        jMenuBar1.add(FileMenu);

        EditMenu.setText("Edit");
        jMenuBar1.add(EditMenu);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 279, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void OpenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_OpenActionPerformed
        JFileChooser fc = new JFileChooser();
        fc.setDialogTitle("Select Image Folder"); 
        fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        if(fc.showOpenDialog(this) == JFileChooser.APPROVE_OPTION){
            File dir = fc.getSelectedFile();
            records.clear();
            convert(dir.getPath());
        }
    }//GEN-LAST:event_OpenActionPerformed

    private void SaveAsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SaveAsActionPerformed
        JFileChooser fc = new JFileChooser();
        fc.setDialogTitle("Save CSV File");
        fc.setFileFilter(new FileNameExtensionFilter("csv file","csv"));

        if(fc.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
            File out = fc.getSelectedFile();
            String path = out.getPath();
            if(!path.endsWith(".csv"))
                path += ".csv";
            writeCSV(path);
        }
    }//GEN-LAST:event_SaveAsActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(BEEtag.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        
        BEEtag bt = new BEEtag();
        bt.records = new ArrayList<>();
        bt.RecordTable.setRowHeight(bt.rowsize);
        bt.RecordTable.setDefaultRenderer(String.class, new MultiLineCellRenderer());

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            bt.setVisible(true);
        });
    }
    
    private void convert(String inFile){
        File dir = new File(inFile);
        final String[] col = {"Image", "Decoded", "ID", "Time"};
        DefaultTableModel mod = new DefaultTableModel(col, 0){
            @Override
            public Class getColumnClass(int columnIndex) {
                if(columnIndex == 0)
                    return Icon.class;
                else
                    return String.class;
            }
            
            @Override
            public boolean isCellEditable(int row, int column) {
               //all cells false
               return false;
            }
        };
        
        for(File imgFile : dir.listFiles()){
            BufferedImage img;
            BasicFileAttributes attr;
            try{
                //get image to buffered image
                img = ImageIO.read(imgFile);
                attr = Files.readAttributes(imgFile.toPath(), BasicFileAttributes.class);
            }
            catch(IOException e){
                System.err.println("Invalid image file " + imgFile.getPath() + ".");
                continue;
            }

            int[] intArray = img.getRGB(0, 0, img.getWidth(), img.getHeight(), null, 0, img.getWidth());

            //create LuminanceSource and run through Binarizer to get BinaryBitmap
            LuminanceSource source = new RGBLuminanceSource(img.getWidth(), img.getHeight(), intArray);
            BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));
            BitMatrix bits;

            try{
                //find code in picture and return corner locations
                WhiteRectangleDetector detector = new WhiteRectangleDetector(bitmap.getBlackMatrix());
                ResultPoint[] corners = detector.detect();

                //convert code into its binary representation stored in BitMatrix
                GridSampler sampler = GridSampler.getInstance();
                bits = sampler.sampleGrid(bitmap.getBlackMatrix(), 5, 5,
                        0.5f, 0.5f, 5-0.5f, 0.5f, 5-0.5f, 5-0.5f, 0.5f, 5-0.5f,
                        corners[0].getX(), corners[0].getY(), corners[2].getX(), corners[2].getY(),
                        corners[3].getX(), corners[3].getY(), corners[1].getX(), corners[1].getY());
            }
            catch(NotFoundException e){
                //couldn't find code in image
                System.err.println("Error: No valid code found in " + imgFile.getName() + ".");
                continue;
            }
            
            //NOTE: "row" and "column" are used below referring to the original orientation of the tag
            //The BEEtag specification uses "column" to refer to rows in the original orientation when mentioning the parity format
            //Also note that BEEtag uses white for 1 and 0 for black while ZXing uses true for black and false for white.
            int dec = -1;

            for(int i = 0; i < 4; i++){
                dec = decode(bits);
                if(dec != -1) { //found valid tag orientation
                    ArrayList<String> values = new ArrayList<>(); //list of strings to write to csv
                    values.add(bits.toString());
                    values.add(Integer.toString(dec)); //tag ID
                    values.add(attr.creationTime().toString()); //file creation time (temp)
                    records.add(values); //save to records arraylist
                    
                    Object[] row = new Object[values.size()+1]; //leave space for thumbnail
                
                    //scale down image to thumbnail size
                    BufferedImage thumb = new BufferedImage(rowsize, rowsize, BufferedImage.TYPE_INT_RGB);
                    Graphics g = thumb.createGraphics();
                    g.drawImage(img, 0, 0, rowsize, rowsize, null);
                    g.dispose();

                    //create icon from image and put in row
                    ImageIcon icon = new ImageIcon(thumb);
                    row[0] = icon;
                    for(int j=0; j<values.size(); j++)
                        row[j+1] = values.get(j);

                    //add row to table
                    mod.addRow(row);
                    break;
                }else{
                    bits = rotate(bits, 5);
                }
            }
            
            if(dec == -1){
                //all parity checks failed, display error message
                System.err.println("Error: All orientations failed for " + imgFile.getName() + ".");
                
                //show user failed read in table but don't write to csv
                ArrayList<String> values = new ArrayList<>(); //list of strings to write to csv
                values.add(bits.toString());
                values.add("ERROR"); //tag ID
                values.add(attr.creationTime().toString()); //file creation time (temp)

                Object[] row = new Object[values.size()+1]; //leave space for thumbnail
                
                //scale down image to thumbnail size
                BufferedImage thumb = new BufferedImage(rowsize, rowsize, BufferedImage.TYPE_INT_RGB);
                Graphics g = thumb.createGraphics();
                g.drawImage(img, 0, 0, rowsize, rowsize, null);
                g.dispose();
                
                //create icon from image and put in row
                ImageIcon icon = new ImageIcon(thumb);
                row[0] = icon;
                for(int j=0; j<values.size(); j++)
                    row[j+1] = values.get(j);
                
                //add row to table
                mod.addRow(row);
            }
        } //for all files in directory
        RecordTable.setModel(mod);
    } //convert

    private BitMatrix rotate(BitMatrix bits, int size){
        BitMatrix x = new BitMatrix(size, size);
        for (int i = 0; i < size; ++i) {
            for (int j = 0; j < size; ++j) {
                if(bits.get(size - j - 1, i))
                    x.set(i, j);
            }
        }
        return x;
    } //rotate

    private int decode(BitMatrix bits){
        int dec = 0; //stores decimal number of tag
        int[] par = new int[5]; //stores expected parity results

        //convert BitMatrix into decimal representation and set column parity bits
        for(int i=0; i<3; i++){ //for first 3 columns
            par[i] = 0; //initialize to even (0)

            for(int j=0; j<5; j++){ //for each row
                if(!bits.get(i, j)) { //if white square (representing 1)
                    dec += Math.pow(2, 14 - 5 * i - j);
                    par[i] = 1 - par[i]; //flip parity for each white
                }
            }
        }

        //set last two parity bits
        par[3] = 0; //initialize to even (0)
        for(int j=0; j<3; j++){ //for first 3 rows
            for(int i=0; i<3; i++){ //for first 3 columns
                if(!bits.get(i, j)) { //if white square (representing 1)
                    par[3] = 1 - par[3]; //flip parity for each white
                }
            }
        }

        par[4] = 0; //initialize to even (0)
        for(int j=3; j<5; j++){ //for last 2 rows
            for(int i=0; i<3; i++){ //for first 3 columns
                if(!bits.get(i, j)) { //if white square (representing 1)
                    par[4] = 1 - par[4]; //flip parity for each white
                }
            }
        }

        //check parity for 4th column
        for(int j=0; j<5; j++){ //for each row
            if((!bits.get(3, j) && par[j] == 0) || (bits.get(3, j) && par[j] == 1)){ //if failed parity check
                return -1;
            }
        }

        //check parity for 5th column (reverse of 4th column)
        for(int j=0; j<5; j++){ //for each row
            if((!bits.get(4, j) && par[4-j] == 0) || (bits.get(4, j) && par[4-j] == 1)){ //if failed parity check
                return -1;
            }
        }
        return dec;
    } //decode
    
    private void writeCSV(String outFile)
    {
        if(records.isEmpty()){
            System.err.println("Nothing to save.");
            return;
        }
        
        try(FileWriter writer = new FileWriter(outFile)) {
            writer.append("ID,Time\n"); //write header

            for(ArrayList<String> record : records){ //for each record
                writer.append(record.get(1)); //start at 1 to skip bit matrix
                for(int i=2; i<record.size(); i++){ //for each element in record
                    writer.append("," + record.get(i));
                } //for each element in record
                writer.append("\n");
            } //for each record

            writer.flush();
            System.out.println("Wrote to output file " + outFile + ".");
        }
        catch(IOException e){
            System.err.println("Failed to write to CSV.");
        }
    } //writeCSV

    private final int rowsize = 80;
    private ArrayList<ArrayList<String>> records;
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenu EditMenu;
    private javax.swing.JMenu FileMenu;
    private javax.swing.JMenuItem Open;
    private javax.swing.JTable RecordTable;
    private javax.swing.JMenuItem SaveAs;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JScrollPane jScrollPane1;
    // End of variables declaration//GEN-END:variables
}


class MultiLineCellRenderer extends JTextArea implements TableCellRenderer {
  @Override
  public Component getTableCellRendererComponent(JTable table, Object value,
      boolean isSelected, boolean hasFocus, int row, int column) {
    if (isSelected) {
      setForeground(table.getSelectionForeground());
      setBackground(table.getSelectionBackground());
    } else {
      setForeground(table.getForeground());
      setBackground(table.getBackground());
    }
    setFont(table.getFont());
    if (hasFocus) {
      setBorder(UIManager.getBorder("Table.focusCellHighlightBorder"));
      if (table.isCellEditable(row, column)) {
        setForeground(UIManager.getColor("Table.focusCellForeground"));
        setBackground(UIManager.getColor("Table.focusCellBackground"));
      }
    } else {
      setBorder(new EmptyBorder(1, 2, 1, 2));
    }
    setText((value == null) ? "" : value.toString());
    return this;
  }
}
